---
title: MongoDB as RDF triple store based on Node.js
created: !!timestamp '2011-09-23 00:00:00'
tags:
- MongoDB
- Nodejs
- RDF
image: http://www.kendix.org/images/13.png
---

{% mark excerpt -%}

This is a short summary of my [bachelor thesis]({{ media_url('files/thesis.pdf') }}) that was written in German. Maybe someone else is interested in the results.

## About

The topic of the thesis was “Implementing a RDF storage solution for [MongoDB](http://mongodb.org/)”. Besides this implementation part the performance of the written API was compared to [Virtuoso Open-Source](http://www.openlinksw.com/dataspace/dav/wiki/Main/).

So, to summarize this thesis, the main question is “Could MongoDB be an alternative to Virtuoso as triple store?”.

{%- endmark %}

## Implementation

There was prior work on this topic such as [this](http://wwaites.posterous.com/mongo-as-an-rdf-store) or [that](http://www.dotnetrdf.org/blogitem.asp?blogID=35) but no scientific evaluation of the systems.
You can find the written API for [Node.js](http://nodejs.org/) [here](https://github.com/kenda/node_mongo_rdf). It mainly implements an insert method and some query methods. For details take a look at the README. There are also explanations about the URI transformation methods that avoids dots in the key identifier of the JSON objects.

## Evaluation

A short explanation of the systems and the data sets.

### systems

*nested* a.k.a *flat*: MongoDB implementation with the nested uri transformation

*dict*: MongoDB implementation with the dict uri transformation

*virtNative*: Virtuoso via ODBC interface

*virtHttp*: Virtuoso via HTTP

### data sets
<table style="margin-left:20px;">
  <tbody><tr>
      <th>abbr. </th>
      <th>subjects </th>
      <th>triples </th>
    </tr>
    <tr>
      <td>2k</td>
      <td>2056</td>
      <td>10698</td>
    </tr>
    <tr>
      <td>5k</td>
      <td>5464</td>
      <td>29446</td>
    </tr>
    <tr>
      <td>10k</td>
      <td>9830</td>
      <td>59431</td>
    </tr>
    <tr>
      <td>20k</td>
      <td>19583</td>
      <td>110431</td>
    </tr>
    <tr>
      <td>40k</td>
      <td>41901</td>
      <td>238965</td>
    </tr>
  </tbody>
</table>

#### Insert
<a href="http://www.kendix.org/images/11.png" class="fancy"><img src="http://www.kendix.org/images/11.png" class="fancy" alt="Insert results" /></a>

<table style="margin-left:10px;">
  <tbody><tr>
      <th></th>
      <th>nested </th>
      <th>dict </th>
      <th>virtNative </th>
      <th>virtHttp</th>
    </tr>
    <tr>
      <td>2k</td>
      <td> 1.609s</td>
      <td> 10.031s</td>
      <td> 0.512s</td>
      <td> 1.415s</td>
    </tr>
    <tr>
      <td>5k</td>
      <td> 7.811s</td>
      <td> 30.522s</td>
      <td> 1.300s</td>
      <td> 3.163s</td>
    </tr>
    <tr>
      <td>10k</td>
      <td> 23.148s</td>
      <td> 83.707s</td>
      <td> 2.697s</td>
      <td> 6.368s</td>
    </tr>
    <tr>
      <td>20k</td>
      <td> 176.297s</td>
      <td> 251.442s</td>
      <td> 5.674s</td>
      <td> 13.605s</td>
    </tr>
    <tr>
      <td>40k</td>
      <td> 733.773s</td>
      <td> 998.763s</td>
      <td> 15.153s</td>
      <td> 42.731s</td>
    </tr>
  </tbody>
</table>

As you can see, both MongoDB implementations are extremely slow inserting the triples. There are differences of 15 minutes and more! But it’s hard to say what the reasons for this results are. Because of the [mentioned](http://www.dotnetrdf.org/blogitem.asp?blogID=35) article which presents similar results, we can only guess that MongoDB itself is the reason and not the implementations. Maybe it has something to do with updating the indices.

#### Query

<a href="http://www.kendix.org/images/12.png" class="fancy"><img src="http://www.kendix.org/images/12.png" alt="Query results" /></a>
<table style="margin-left:10px;">
  <tbody><tr>
      <th></th>
      <th>nested </th>
      <th>dict </th>
      <th>virtNative </th>
      <th>virtHttp</th>
    </tr>
    <tr>
      <td>2k</td>
      <td> 1.609s</td>
      <td> 10.031s</td>
      <td> 0.512s</td>
      <td> 1.415s</td>
    </tr>
    <tr>
      <td>5k</td>
      <td> 7.811s</td>
      <td> 30.522s</td>
      <td> 1.300s</td>
      <td> 3.163s</td>
    </tr>
    <tr>
      <td>10k</td>
      <td> 23.148s</td>
      <td> 83.707s</td>
      <td> 2.697s</td>
      <td> 6.368s</td>
    </tr>
    <tr>
      <td>20k</td>
      <td> 176.297s</td>
      <td> 251.442s</td>
      <td> 5.674s</td>
      <td> 13.605s</td>
    </tr>
    <tr>
      <td>40k</td>
      <td> 733.773s</td>
      <td> 998.763s</td>
      <td> 15.153s</td>
      <td> 42.731s</td>
    </tr>
  </tbody>
</table>

The results of the probably most used query method findBySubject() are quite better than the insert ones. While Virtuoso via ODBC is the fastest implementation, the MongoDB implementation nested is faster than Virtuoso via HTTP. The second MongoDB implementation is continously the slowest system.

For the results of the other query methods, please take a look in the thesis.

## Conclusion

1. The implementation dict is continously the slowest one.
2. The implementation nested is in four of five query methods faster than Virtuoso via HTTP
3. Virtuoso via ODBC is continously the fastest system.

Overall: With the results in mind, we can draw the conclusion that MongoDB as a triple store is only useful with small to mid sized data sets. Furthermore it is advisable to use it only in query-oriented environments because of the lacking performance inserting triples.
